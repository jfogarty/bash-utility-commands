#!/bin/bash
# ----------------------------------------------------------------------------
# Go to a directory based on past history.
# ----------------------------------------------------------------------------
# V1.1 - 04 Jan 2017
# ----------------------------------------------------------------------------
# John Fogarty - MIT License or Free License 1.0.0 - NO rights reserved.
# ----------------------------------------------------------------------------

declare fullScriptName=$_
declare scriptName=$(basename $0)
declare docName="toDir"

declare verbose=0
declare trial=0
declare quiet=0
declare inshell=0
declare memoFile="~/etc/toDirs.txt"
declare tmpFile="/tmp/out_${docName}_$$"
memoFile="${memoFile/#\~/$HOME}"

#------------------------------------------------------------------------
# Terminate the script or the command shell
#   Usage: sexit [value]; if [[ $exiting -ne 0 ]]; then return; fi
function sexit()
{
    rval=$1
    exiting=1
}

# echo text if not quiet
function qecho()
{
	if [[ $quiet -eq 0 ]]; then
		echo "$@"
	fi
}

# echo text if in verbose mode.
function vecho()
{
	if [[ $verbose -eq 1 ]]; then
		echo "$@"
	fi
}

# printf text if not quiet
function qprintf()
{
	if [[ $quiet -eq 0 ]]; then
		printf "$@"
	fi
}

# printf text if in verbose mode.
function vprintf()
{
	if [[ $verbose -eq 1 ]]; then
		printf "$@"
	fi
}

# execute a command (or display it if not sourced to the shell.
function runinshell()
{
	if [[ $inshell -eq 1 ]]; then
		vecho "eval: $@"
		if [[ $trial -eq 0 ]]; then 
    		eval $@
    	fi
	else
		qecho "$@"
	fi
}

# prepend a line to the start of a file.
function prependLine()
{
	local line="$1"
	local theFile="$2"
	echo "$line"|cat - "$theFile" > "$tmpFile" && mv "$tmpFile" "$theFile"
}

# remove a matching line from anywhere in the file.
function removeLine()
{
	local line="${1//\//\\\/}"
	local theFile="$2"
	sed "/^$line\$/d" "$memoFile" > "$tmpFile" && mv "$tmpFile" "$theFile"
}

#------------------------------------------------------------------------
function scriptUsage()
{
    echo "Usage: . $docName [options] [dir]"
    echo "Go to a recently used directory."
    echo ""
    echo "-l             list the current memofile."
    echo "-q             quiet output - only errors displayed."
    echo "-v             verbose output during command execution."
    echo ""
    echo "Each time you use '$docName', the current directory is put at the"
    echo "top of a list of available directories.  The 'dir' you specify is"
    echo "looked up in the list and chdir to that directory is issued."
    echo "You can also use any valid relative directory name."
    echo "Use .. or ... or  .... to pop to previous directories."
    vecho ""
    vecho "NOTE you must source command with the prefixed '. ' or source:"
    vecho ""
    vecho "    . $docName [options] [dir]"
    vecho ""
    vecho "otherwise the cd command will just be displayed and you will"
    vecho "stay in the current directory."
    vecho ""
    vecho "I place an alias t=. $docName in my .bashrc file for convenience."
    vecho "Edit $memoFile if you need to remove some trash."
    vecho ""
    sexit 1
}

function addDir()
{
    local wd=`readlink -f "$1"`
	# ----- Add the current directory to the top of the directory list.
	if grep -qx "$wd" "$memoFile"; then
		removeLine "$wd" "$memoFile"
	fi
    prependLine "$wd" "$memoFile"
}

function deleteFile()
{
    local theFile="$1"
    if [[ -n "$theFile" ]]; then
        if [[ -e "$theFile" ]]; then
            rm "$theFile"
        fi
    fi
}

# Removes any non-existant directories from the list
function cleanDirs()
{
    local removeStuff=0
    local dirPath
    local d='directory'
    local c=0
    while read dirPath
    do
        if [[ -n "$dirPath" ]]; then # Allow blank lines
            if [[ ! -e "$dirPath" ]]; then
                qprintf "%s Missing Directory [%s]\n" '*' $dirPath
                if [[ $removeStuff -eq 1 ]]; then d='directories'; fi
                removeStuff=1
                let c+=1
            fi
        fi
    done < "$memoFile"
    if [[ $removeStuff -eq 1 ]]; then
        vprintf "%s Removing %d non-existent %s from %s\n" '-' $c $d "$memoFile"
        deleteFile "$tmpFile"
        while read dirPath; do
            if [[ -z "$dirPath" ]]; then # Allow blank lines
                echo "$dirPath" >> "$tmpFile"
            else
                if [[ -e "$dirPath" ]]; then
                    echo "$dirPath" >> "$tmpFile"
                fi
            fi
        done < "$memoFile"        
        mv "$tmpFile" "$memoFile"
    fi
}

function main()
{
	local dirName="$1"
	local wd=`pwd`

	if [[ -e "$memoFile" ]]; then
	    cleanDirs
    	addDir "$wd"
   	else
		vecho "- New memo file: [$memoFile]"
		echo "$wd" > "$memoFile"
	fi

	vecho memoFile="$memoFile"

	local dest
    local lineNumber=2
	if [[ -n "$dirName" ]]; then
		if [[ "$dirName" == "?" ]]; then
			scriptUsage
		fi
        #echo "* Try to find [$dirName]"
        if [[ "$dirName" == ".." ]]; then
	        dest=`sed "${lineNumber}q;d" "$memoFile"`
   			addDir "$dest"
            vecho "* POPTO [$dest]"		
        elif [[ "$dirName" == "..." ]]; then
            lineNumber=3
	        dest=`sed "${lineNumber}q;d" "$memoFile"`
   			addDir "$dest"
            vecho "* POPTO [$dest]"		
        elif [[ "$dirName" == "...." ]]; then
            lineNumber=4
	        dest=`sed "${lineNumber}q;d" "$memoFile"`
   			addDir "$dest"
            vecho "* POPTO [$dest]"
		elif grep -q "/$dirName$" "$memoFile"; then
			vecho "* FOUND [$dirName]"
			dest=`grep -m1 "/$dirName$" "$memoFile"`            
		elif grep -q "$dirName$" "$memoFile"; then
			vecho "* FOUND [$dirName]"
			dest=`grep -m1 "$dirName$" "$memoFile"`
		else
			if grep -q "$dirName" "$memoFile"; then
				#echo "* FOUND [$dirName]"
				dest=`grep -m1 "$dirName" "$memoFile"`
			else
		        if [[ -d "$dirName" ]]; then
           			dest=`readlink -f "$dirName"`
           			addDir "$dest"
                    vecho "* CHDIR [$dest]"
           		else
           			for localDirName in */ ; do
           			    if [[ -z $dest ]]; then 
               			    if [[ $localDirName == *"$dirName"* ]]; then
                       			dest=`readlink -f "$localDirName"`
                       			addDir "$dest"
                                vecho "* CHDIR [$dest]"               			        
               			    fi
               			fi
                	done
                	if [[ -z $dest ]]; then 
				        echo "Sorry, [$dirName] not found in $memoFile."
				        if [[ $verbose -eq 1 ]]; then
					        cat "$memoFile"
				        fi
				    fi
				fi
			fi
		fi
		if [[ -n "$dest" ]]; then 
			runinshell "cd \"$dest\""
		fi
	else
		if [[ $verbose -eq 1 ]]; then
		    cat "$memoFile"
		fi
	fi
}

if [[ "$scriptName" == "bash" ]]; then
    inshell=1
fi
OPTIND=1 # Reset in case getopts has been used previously in the shell.
while getopts "hl?qvt" opt; do
    case "$opt" in
        l)  echo "- memoFile="$memoFile""
            cat "$memoFile"
            scriptUsage
            return $rval
            ;;       
        v)  verbose=1
            ;;
        q)  quiet=1
            ;;
        t)  trial=1
            ;;    	
        h|\?)
            scriptUsage
            return $rval
            ;;
    esac
done
shift $((OPTIND-1))
[ "$1" = "--" ] && shift
main "$@"
